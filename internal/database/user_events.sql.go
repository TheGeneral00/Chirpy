// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_events.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countEventsByAction = `-- name: CountEventsByAction :one
SELECT COUNT(*) FROM user_events
WHERE method = $1
`

func (q *Queries) CountEventsByAction(ctx context.Context, method string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventsByAction, method)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventsByIP = `-- name: CountEventsByIP :one
SELECT COUNT(*) FROM user_events
WHERE method_details::json->>'ip' = $1
`

func (q *Queries) CountEventsByIP(ctx context.Context, methodDetails string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventsByIP, methodDetails)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventsByUser = `-- name: CountEventsByUser :one
SELECT COUNT(*) FROM user_events 
WHERE user_id = $1
`

func (q *Queries) CountEventsByUser(ctx context.Context, userID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserEvent = `-- name: CreateUserEvent :one
INSERT INTO user_events(request_id, event_seq, user_id, method, method_details, created_at)
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        Now()
)
RETURNING request_id
`

type CreateUserEventParams struct {
	RequestID     uuid.UUID
	EventSeq      int32
	UserID        uuid.NullUUID
	Method        string
	MethodDetails string
}

func (q *Queries) CreateUserEvent(ctx context.Context, arg CreateUserEventParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUserEvent,
		arg.RequestID,
		arg.EventSeq,
		arg.UserID,
		arg.Method,
		arg.MethodDetails,
	)
	var request_id uuid.UUID
	err := row.Scan(&request_id)
	return request_id, err
}

const getEventCount = `-- name: GetEventCount :one
SELECT COUNT(*) FROM user_events
`

func (q *Queries) GetEventCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getEventCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEvents = `-- name: GetEvents :many
SELECT request_id, event_seq, user_id, method, method_details, created_at, state FROM user_events
ORDER BY created_at DESC
`

func (q *Queries) GetEvents(ctx context.Context) ([]UserEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEvent
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.RequestID,
			&i.EventSeq,
			&i.UserID,
			&i.Method,
			&i.MethodDetails,
			&i.CreatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByAction = `-- name: GetEventsByAction :many
SELECT request_id, event_seq, user_id, method, method_details, created_at, state FROM user_events
WHERE method = $1
ORDER BY  created_at DESC
`

func (q *Queries) GetEventsByAction(ctx context.Context, method string) ([]UserEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByAction, method)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEvent
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.RequestID,
			&i.EventSeq,
			&i.UserID,
			&i.Method,
			&i.MethodDetails,
			&i.CreatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByEndpoint = `-- name: GetEventsByEndpoint :many
SELECT request_id, event_seq, user_id, method, method_details, created_at, state FROM user_events
WHERE method_details::json->>'endpoint' = $1
ORDER BY created_at DESC
`

func (q *Queries) GetEventsByEndpoint(ctx context.Context, methodDetails string) ([]UserEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByEndpoint, methodDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEvent
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.RequestID,
			&i.EventSeq,
			&i.UserID,
			&i.Method,
			&i.MethodDetails,
			&i.CreatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByIP = `-- name: GetEventsByIP :many
SELECT request_id, event_seq, user_id, method, method_details, created_at, state FROM user_events
WHERE method_details::json->>'ip' = $1
ORDER BY created_at DESC
`

func (q *Queries) GetEventsByIP(ctx context.Context, methodDetails string) ([]UserEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByIP, methodDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEvent
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.RequestID,
			&i.EventSeq,
			&i.UserID,
			&i.Method,
			&i.MethodDetails,
			&i.CreatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByUser = `-- name: GetEventsByUser :many
SELECT request_id, event_seq, user_id, method, method_details, created_at, state  FROM user_events
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetEventsByUser(ctx context.Context, userID uuid.NullUUID) ([]UserEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEvent
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.RequestID,
			&i.EventSeq,
			&i.UserID,
			&i.Method,
			&i.MethodDetails,
			&i.CreatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsInTimeWindow = `-- name: GetEventsInTimeWindow :many
SELECT request_id, event_seq, user_id, method, method_details, created_at, state FROM user_events
WHERE created_at BETWEEN $1 AND $2
ORDER BY created_at DESC
`

type GetEventsInTimeWindowParams struct {
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

func (q *Queries) GetEventsInTimeWindow(ctx context.Context, arg GetEventsInTimeWindowParams) ([]UserEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEventsInTimeWindow, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEvent
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.RequestID,
			&i.EventSeq,
			&i.UserID,
			&i.Method,
			&i.MethodDetails,
			&i.CreatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestEvents = `-- name: GetLatestEvents :many
SELECT request_id, event_seq, user_id, method, method_details, created_at, state FROM user_events
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetLatestEvents(ctx context.Context, limit int32) ([]UserEvent, error) {
	rows, err := q.db.QueryContext(ctx, getLatestEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEvent
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.RequestID,
			&i.EventSeq,
			&i.UserID,
			&i.Method,
			&i.MethodDetails,
			&i.CreatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestEventsByUser = `-- name: GetLatestEventsByUser :many
SELECT request_id, event_seq, user_id, method, method_details, created_at, state FROM user_events
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetLatestEventsByUserParams struct {
	UserID uuid.NullUUID
	Limit  int32
}

func (q *Queries) GetLatestEventsByUser(ctx context.Context, arg GetLatestEventsByUserParams) ([]UserEvent, error) {
	rows, err := q.db.QueryContext(ctx, getLatestEventsByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEvent
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.RequestID,
			&i.EventSeq,
			&i.UserID,
			&i.Method,
			&i.MethodDetails,
			&i.CreatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getState = `-- name: GetState :one
SELECT state FROM user_events
WHERE request_id = $1
`

func (q *Queries) GetState(ctx context.Context, requestID uuid.UUID) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getState, requestID)
	var state sql.NullString
	err := row.Scan(&state)
	return state, err
}

const resetEvents = `-- name: ResetEvents :exec
TRUNCATE TABLE user_events RESTART IDENTITY
`

func (q *Queries) ResetEvents(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetEvents)
	return err
}

const setStateFailure = `-- name: SetStateFailure :exec
UPDATE user_events
SET state = 'Failure'
WHERE request_id = $1
`

func (q *Queries) SetStateFailure(ctx context.Context, requestID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setStateFailure, requestID)
	return err
}

const setStatePending = `-- name: SetStatePending :exec
UPDATE user_events
SET state = 'Pending'
WHERE request_id = $1
`

func (q *Queries) SetStatePending(ctx context.Context, requestID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setStatePending, requestID)
	return err
}

const setStateSuccess = `-- name: SetStateSuccess :exec
UPDATE user_events 
SET state = 'Success'
WHERE request_id = $1
`

func (q *Queries) SetStateSuccess(ctx context.Context, requestID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setStateSuccess, requestID)
	return err
}
